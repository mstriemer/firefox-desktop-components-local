{"version":3,"file":"icon-directory-stories.4bb0041d.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AAMA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AARA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AAHA;AAwHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AAAA;AAKA;AACA;AACA;AAUA;AAUA;AAAA;AAAA;AAAA;AAEA;AACA;AAwBA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AASA;AAAA;AAAA;AA/PA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AA4PA;AAEA;AACA;AACA","sources":["webpack:///./stories/icon-directory.stories.mjs"],"sourcesContent":["import __chrome_styles_loader__textandtypographyStyles from \"toolkit/themes/shared/design-system/src/text-and-typography.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {\n  LitElement,\n  html,\n  classMap,\n  css,\n} from \"chrome://global/content/vendor/lit.all.mjs\";\nimport chromeMap from \"../.storybook/chrome-map.js\";\n\nexport default {\n  title: \"Docs/Icon Directory\",\n  parameters: {\n    options: { showPanel: false },\n    docs: { source: { state: \"closed\" } },\n  },\n};\n\n/**\n * Group the icons by their file path.\n *\n * @param {Map<string, string[]>} groups\n * Mapping of folder path to file name array\n */\nfunction prioritizeGroups(groups) {\n  let bundleGroupings = [\n    \"browser/themes\",\n    \"toolkit/themes\",\n    \"browser/components\",\n    \"toolkit/components\",\n  ];\n  let newGroups = new Map(bundleGroupings.map(bg => [bg, []]));\n  for (let group of groups.keys()) {\n    let bundleGroup =\n      bundleGroupings.find(bundleGroup => group.startsWith(bundleGroup)) ||\n      group;\n    if (!newGroups.has(bundleGroup)) {\n      newGroups.set(bundleGroup, []);\n    }\n    newGroups.get(bundleGroup).push(...groups.get(group));\n  }\n  for (let icons of newGroups.values()) {\n    icons.sort();\n  }\n  return newGroups;\n}\n\nfunction buildIconData() {\n  const [prefixMap, , sourceMap] = chromeMap;\n\n  // Build reverse lookup: bundleDir -> chromePrefix\n  const reversePrefixMap = new Map();\n  for (const [chromePrefix, bundleDirs] of Object.entries(prefixMap)) {\n    for (const dir of bundleDirs) {\n      reversePrefixMap.set(dir, chromePrefix);\n    }\n  }\n\n  function resolveToChrome(bundlePath) {\n    let dirPath = bundlePath;\n    while (dirPath.includes(\"/\")) {\n      let lastSlash = dirPath.lastIndexOf(\"/\");\n      let dir = dirPath.substring(0, lastSlash);\n      let remainder = bundlePath.substring(dir.length + 1);\n      let chromePrefix = reversePrefixMap.get(dir);\n      if (chromePrefix) {\n        return chromePrefix + remainder;\n      }\n      dirPath = dir;\n    }\n    return null;\n  }\n\n  const groups = new Map();\n  for (const [bundlePath, [srcPath]] of Object.entries(sourceMap)) {\n    if (!bundlePath.endsWith(\".svg\")) {\n      continue;\n    }\n    let chromeUri = resolveToChrome(bundlePath);\n    if (\n      !chromeUri ||\n      !(\n        chromeUri.startsWith(\"chrome://browser/\") ||\n        chromeUri.startsWith(\"chrome://global\")\n      )\n    ) {\n      continue;\n    }\n    let lastSlash = srcPath.lastIndexOf(\"/\");\n    let bundleDir = srcPath.substring(0, lastSlash);\n    let fileName = srcPath.substring(lastSlash + 1);\n    if (!groups.has(bundleDir)) {\n      groups.set(bundleDir, []);\n    }\n    groups.get(bundleDir).push({ chromeUri, fileName, filePath: srcPath });\n  }\n\n  for (const icons of groups.values()) {\n    icons.sort((a, b) => a.fileName.localeCompare(b.fileName));\n  }\n\n  return prioritizeGroups(groups);\n}\n\nconst iconData = buildIconData();\n\nfunction rgbToHex(rgb) {\n  let match = rgb.match(/\\d+/g);\n  if (!match || match.length < 3) {\n    return \"#000000\";\n  }\n  return (\n    \"#\" +\n    match\n      .slice(0, 3)\n      .map(n => parseInt(n).toString(16).padStart(2, \"0\"))\n      .join(\"\")\n  );\n}\n\n/**\n * Browsable, searchable directory of SVG icons available in the Firefox\n * codebase, grouped by source directory with chrome:// URI previews.\n */\nclass IconDirectory extends LitElement {\n  static properties = {\n    filter: { type: String, state: true },\n    fillColor: { type: String, state: true },\n    strokeColor: { type: String, state: true },\n    iconSize: { type: String, reflect: true },\n  };\n\n  static styles = css`\n    :host {\n      --icon-item-width: 125px;\n      --icon-item-padding: var(--space-small);\n      --icon-item-fill: var(--icon-color);\n      /*\n       * The rgbToHex function doesn't work with oklch...\n       * Use --color-accent-primary manual conversion to hex so the stroke is more visible.\n       */\n      --icon-item-stroke: light-dark(#0062fa, #00cadb);\n      --icon-item-width-content: calc(\n        var(--icon-item-width) - 2 * var(--icon-item-padding)\n      );\n\n      display: flex;\n      flex-direction: column;\n      gap: var(--space-large);\n    }\n\n    #color-probe {\n      display: none;\n      fill: var(--icon-item-fill);\n      stroke: var(--icon-item-stroke);\n    }\n\n    moz-box-item {\n      --box-padding: var(--icon-item-padding);\n    }\n\n    .view-controls {\n      display: flex;\n      align-items: center;\n      gap: var(--space-large);\n    }\n\n    .icon-list {\n      display: grid;\n      grid-template-columns: repeat(\n        auto-fill,\n        minmax(var(--icon-item-width), 1fr)\n      );\n      gap: var(--space-small);\n    }\n\n    .icon-item {\n      anchor-name: --icon-item;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n\n      img {\n        -moz-context-properties: fill, stroke;\n        fill: var(--icon-item-fill);\n        stroke: var(--icon-item-stroke);\n\n        :host([iconsize=\"normalize\"]) & {\n          width: 16px;\n          aspect-ratio: 1;\n\n          &.icon-12 {\n            width: 12px;\n          }\n\n          &.icon-24 {\n            width: 24px;\n          }\n        }\n\n        :host([iconsize=\"full\"]) & {\n          max-width: var(--icon-item-width-content);\n        }\n      }\n    }\n\n    .icon-name {\n      font-size: var(--font-size-small);\n      width: var(--icon-item-width-content);\n      margin: var(--icon-item-padding) auto 0;\n\n      button& {\n        appearance: none;\n        border: none;\n        background: none;\n        cursor: pointer;\n        padding: 0;\n      }\n    }\n\n    #success-message {\n      display: none;\n      inset-block-start: anchor(end);\n      inset-inline-start: anchor(center);\n      translate: -50%;\n      margin: 0;\n      transition: opacity 250ms;\n      box-shadow: var(--box-shadow-popup);\n      font-size: var(--font-size-small);\n    }\n\n    #success-message[hiding] {\n      opacity: 0;\n    }\n\n    #success-message:popover-open {\n      display: block;\n    }\n  `;\n\n  constructor() {\n    super();\n    this.filter = \"\";\n    this.fillColor = \"\";\n    this.strokeColor = \"\";\n    this.iconSize = \"normalize\";\n  }\n\n  firstUpdated() {\n    let probe = this.renderRoot.querySelector(\"#color-probe\");\n    let probeStyles = getComputedStyle(probe);\n    this.fillColor = rgbToHex(probeStyles.fill);\n    this.strokeColor = rgbToHex(probeStyles.stroke);\n  }\n\n  get successMessageBar() {\n    return this.renderRoot.querySelector(\"#success-message\");\n  }\n\n  handleSearch(e) {\n    this.filter = e.detail.query.toLowerCase();\n  }\n\n  handleFillChange(e) {\n    this.fillColor = e.target.value;\n    this.style.setProperty(\"--icon-item-fill\", this.fillColor);\n  }\n\n  handleStrokeChange(e) {\n    this.strokeColor = e.target.value;\n    this.style.setProperty(\"--icon-item-stroke\", this.strokeColor);\n  }\n\n  handleCopy(e) {\n    navigator.clipboard.writeText(e.target.dataset.url);\n    this.successMessageBar.removeAttribute(\"hiding\");\n    clearTimeout(this._successMessageTimeout);\n    this._successMessageTimeout = setTimeout(() => {\n      this.successMessageBar.setAttribute(\"hiding\", \"\");\n      this.successMessageBar.addEventListener(\n        \"transitionend\",\n        () => {\n          this.successMessageBar.hidePopover();\n          this.successMessageBar.removeAttribute(\"hiding\");\n        },\n        { once: true }\n      );\n    }, 3000);\n  }\n\n  filteredIcons(icons) {\n    if (!this.filter) {\n      return icons;\n    }\n    return icons.filter(\n      ({ chromeUri, filePath }) =>\n        filePath.toLowerCase().includes(this.filter) ||\n        chromeUri.toLowerCase().includes(this.filter)\n    );\n  }\n\n  renderGroup(dirKey, icons) {\n    let filtered = this.filteredIcons(icons);\n    if (!filtered.length) {\n      return \"\";\n    }\n    return html`\n      <moz-card .heading=${dirKey} type=\"accordion\" expanded>\n        ${html`\n          <div class=\"icon-list\">\n            ${filtered.map(\n              ({ chromeUri, fileName }) => html`\n                <moz-box-item>\n                  <div class=\"icon-item\">\n                    <img\n                      class=${classMap({\n                        \"icon-12\": fileName.endsWith(\"-12.svg\"),\n                        \"icon-24\": fileName.endsWith(\"-24.svg\"),\n                      })}\n                      src=${chromeUri}\n                    />\n                    <button\n                      class=\"icon-name text-truncated-ellipsis\"\n                      data-url=${chromeUri}\n                      @click=${this.handleCopy}\n                      title=${`${fileName} â€” Copy chrome:// URL`}\n                      popovertarget=\"success-message\"\n                    >\n                      ${fileName}\n                    </button>\n                  </div>\n                </moz-box-item>\n              `\n            )}\n          </div>\n        `}\n      </moz-card>\n    `;\n  }\n\n  render() {\n    return html`\n      <link\n        rel=\"stylesheet\"\n        href=\"${__chrome_styles_loader__textandtypographyStyles}\"\n      />\n      <moz-page-header heading=\"Icon Directory\"></moz-page-header>\n      <moz-input-search\n        placeholder=\"Filter icons...\"\n        @MozInputSearch:search=${this.handleSearch}\n      ></moz-input-search>\n      <span id=\"color-probe\"></span>\n      <div class=\"view-controls\">\n        <moz-input-color\n          label=\"Fill\"\n          value=${this.fillColor}\n          @change=${this.handleFillChange}\n        ></moz-input-color>\n        <moz-input-color\n          label=\"Stroke\"\n          value=${this.strokeColor}\n          @change=${this.handleStrokeChange}\n        ></moz-input-color>\n        <moz-toggle\n          label=\"Show full size icons\"\n          @toggle=${e =>\n            (this.iconSize = e.target.pressed ? \"full\" : \"normalize\")}\n        ></moz-toggle>\n      </div>\n      ${[...iconData.entries()].map(([dirKey, icons]) =>\n        this.renderGroup(dirKey, icons)\n      )}\n      <moz-message-bar\n        id=\"success-message\"\n        type=\"success\"\n        message=\"Copied!\"\n        popover=\"hint\"\n      ></moz-message-bar>\n    `;\n  }\n}\n\ncustomElements.define(\"icon-directory\", IconDirectory);\n\nexport const Default = () => {\n  return html`<icon-directory></icon-directory>`;\n};\n"],"names":[],"sourceRoot":""}